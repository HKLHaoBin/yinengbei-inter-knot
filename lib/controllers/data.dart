import 'dart:async';
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:image_picker/image_picker.dart';
import 'package:inter_knot/api/api.dart'; // Import Api
import 'package:inter_knot/api/api_exception.dart';
import 'package:inter_knot/constants/api_config.dart';
import 'package:inter_knot/helpers/box.dart';
import 'package:inter_knot/helpers/dialog_helper.dart';
import 'package:inter_knot/helpers/logger.dart';
import 'package:inter_knot/helpers/num2dur.dart';
import 'package:inter_knot/helpers/throttle.dart';
import 'package:inter_knot/helpers/toast.dart';
import 'package:inter_knot/models/author.dart';
import 'package:inter_knot/models/discussion.dart';
import 'package:inter_knot/models/h_data.dart';
import 'package:inter_knot/pages/login_page.dart';
import 'package:shared_preferences/shared_preferences.dart'; // Standard shared_preferences or specific wrapper?
// The file used SharedPreferencesWithCache which is new in flutter/packages?
// I'll stick to what was there or what works.

// Assuming Controller is registered
final c = Get.find<Controller>();

class Controller extends GetxController {
  late final SharedPreferencesWithCache pref;

  final searchQuery = ''.obs;
  final searchResult = <HDataModel>{}.obs; // HData -> HDataModel
  // Persistent storage key for offline cache
  static const String _searchCacheKey = 'offline_search_cache';
  String? searchEndCur;
  final searchHasNextPage = true.obs;
  final isSearching = false.obs;
  final newPostCount = 0.obs;
  final hasContentChange = false.obs;
  Timer? _newPostCheckTimer;

  String rootToken = '';

  String getToken() => box.read<String>('access_token') ?? '';
  Future<void> setToken(String v) => box.write('access_token', v);
  String getRefreshToken() => pref.getString('refresh_token') ?? '';
  Future<void> setRefreshToken(String v) => pref.setString('refresh_token', v);

  final isLogin = false.obs;
  final user = Rx<AuthorModel?>(null); // Author -> AuthorModel
  final authorId = RxnString();
  final nextEligibleAtUtc = Rxn<DateTime>();
  final myDiscussionsCount = 0.obs;
  final isUploadingAvatar = false.obs;

  final bookmarks = <HDataModel>{}.obs;
  final favoriteIds = <String, String>{}.obs;
  final history = <HDataModel>{}.obs;
  static const String _historyKey = 'history';
  static const String _localReadCacheKey = 'local_read_cache';
  static const String _localViewCacheKey = 'local_view_cache';
  static const int _localCacheMax = 500;
  final _localReadCache = <String, bool>{};
  final _localViewCache = <String, int>{};

  List<String> _encodeHistoryForStorage(Iterable<HDataModel> list) {
    final result = <String>[];
    var count = 0;
    for (final item in list) {
      if (count >= _localCacheMax) break;
      try {
        result.add(jsonEncode(item.toJson()));
        count++;
      } catch (_) {
        // Ignore invalid entries.
      }
    }
    return result;
  }

  void _saveHistoryToLocal() {
    try {
      pref.setStringList(_historyKey, _encodeHistoryForStorage(history));
    } catch (_) {
      // Ignore persistence failures.
    }
  }

  Future<void> refreshMyExp() async {
    final u = user.value;
    if (u == null) return;

    try {
      final expInfo = await api.getMyExp();
      u.exp = expInfo.exp;
      u.level = expInfo.level;
      final last = expInfo.lastCheckInDate;
      if (last != null && last.isNotEmpty) {
        u.lastCheckInDate = last;
      }
      final days = expInfo.consecutiveCheckInDays;
      if (days != null) {
        u.consecutiveCheckInDays = days;
      }

      final next = nextEligibleAtUtc.value;
      if (next != null && !DateTime.now().toUtc().isBefore(next)) {
        nextEligibleAtUtc.value = null;
      }
      user.refresh();
    } catch (e) {
      logger.w('Failed to refresh my exp', error: e);
    }
  }

  // Api instance
  final api = Get.find<Api>();

  String _withCacheBuster(String url) {
    final ts = DateTime.now().millisecondsSinceEpoch;
    return url.contains('?') ? '$url&v=$ts' : '$url?v=$ts';
  }

  String? _avatarCacheKeyForUser(AuthorModel? u) {
    final id = u?.userId;
    if (id != null && id.isNotEmpty) return 'avatar_url_$id';
    final login = u?.login;
    if (login != null && login.isNotEmpty) return 'avatar_url_$login';
    return null;
  }

  void _cacheAvatarForUser(AuthorModel? u, String url) {
    final key = _avatarCacheKeyForUser(u);
    if (key == null) return;
    box.write(key, url);
  }

  String? _getCachedAvatarForUser(AuthorModel? u) {
    final key = _avatarCacheKeyForUser(u);
    if (key == null) return null;
    return box.read<String>(key);
  }

  void _clearCachedAvatarForUser(AuthorModel? u) {
    final key = _avatarCacheKeyForUser(u);
    if (key == null) return;
    box.remove(key);
  }

  Future<void> updateUserAvatarFromDiscussionsCache() async {
    final login = user.value?.login;
    if (login == null || login.isEmpty) return;
    if (user.value?.avatar.isNotEmpty == true) return;

    for (final future in HDataModel.discussionsCache.values) {
      try {
        final discussion = await future;
        if (discussion != null && discussion.author.login == login) {
          final avatar = discussion.author.avatar;
          if (avatar.isNotEmpty) {
            user.value?.avatar = avatar;
            _cacheAvatarForUser(user.value, avatar);
            user.refresh();
            return;
          }
        }
      } catch (_) {
        // Ignore cache errors; continue scanning.
      }
    }
  }

  Future<void> _refreshAvatarCaches(String newUrl) async {
    final login = user.value?.login;
    if (login == null || login.isEmpty) return;

    final futures = HDataModel.discussionsCache.values.toList();
    for (final future in futures) {
      try {
        final discussion = await future;
        if (discussion != null && discussion.author.login == login) {
          discussion.author.avatar = newUrl;
        }
      } catch (_) {
        // Ignore cache update errors.
      }
    }

    searchResult.refresh();
    bookmarks.refresh();
    history.refresh();
  }

  Future<void> refreshSelfUserInfo({bool forceAvatarFetch = true}) async {
    try {
      final u = await api.getSelfUserInfo('');

      try {
        final expInfo = await api.getMyExp();
        u.exp = expInfo.exp;
        u.level = expInfo.level;
        final last = expInfo.lastCheckInDate;
        if (last != null && last.isNotEmpty) {
          u.lastCheckInDate = last;
        }
        final days = expInfo.consecutiveCheckInDays;
        if (days != null) {
          u.consecutiveCheckInDays = days;
        }
      } catch (_) {
        // Ignore exp refresh failures; keep user info usable.
      }

      user(u);
      await ensureAuthorForUser(u);

      if (forceAvatarFetch) {
        final id = authorId.value ?? u.authorId;
        if (id != null && id.isNotEmpty) {
          try {
            final url = await api.getAuthorAvatarUrl(id);
            if (url != null && url.isNotEmpty) {
              u.avatar = _withCacheBuster(url);
            }
          } catch (_) {
            // Ignore forbidden or missing permission.
          }
        }
      }
      if (u.avatar.isEmpty) {
        final cached = _getCachedAvatarForUser(u);
        if (cached != null && cached.isNotEmpty) {
          u.avatar = cached;
        }
      } else {
        _cacheAvatarForUser(u, u.avatar);
      }
      user.refresh();
      await updateUserAvatarFromDiscussionsCache();

      // Refresh discussion count
      final aid = authorId.value ?? u.authorId;
      if (aid != null && aid.isNotEmpty) {
        myDiscussionsCount.value = await api.getUserDiscussionCount(aid);
      }
    } catch (e) {
      logger.e('Failed to refresh self user info', error: e);
    }
  }

  DateTime? _parseYmd(String? ymd) {
    if (ymd == null || ymd.isEmpty) return null;
    final parts = ymd.split('-');
    if (parts.length != 3) return null;
    final y = int.tryParse(parts[0]);
    final m = int.tryParse(parts[1]);
    final d = int.tryParse(parts[2]);
    if (y == null || m == null || d == null) return null;
    return DateTime.utc(y, m, d);
  }

  DateTime? nextCheckInAt(AuthorModel? u) {
    final last = _parseYmd(u?.lastCheckInDate);
    if (last == null) return null;
    // Business rule: next eligible at next check-in day 00:00 (Asia/Shanghai).
    // To avoid relying on device timezone, compute in UTC:
    // 00:00 (UTC+8) == 16:00Z of previous day.
    final nextDay = last.add(const Duration(days: 1));
    return DateTime.utc(nextDay.year, nextDay.month, nextDay.day, 16);
  }

  bool canCheckInNow(AuthorModel? u, {DateTime? now}) {
    final t = (now ?? DateTime.now()).toUtc();
    final overrideNext = nextEligibleAtUtc.value;
    if (overrideNext != null) {
      return !t.isBefore(overrideNext);
    }
    final next = nextCheckInAt(u);
    if (next == null) return true;
    return !t.isBefore(next);
  }

  String? checkInHintText(AuthorModel? u, {DateTime? now}) {
    final t = (now ?? DateTime.now()).toUtc();
    final next = nextEligibleAtUtc.value ?? nextCheckInAt(u);
    if (next == null || !t.isBefore(next)) return null;

    final diff = next.difference(t);
    final hours = diff.inHours.toString().padLeft(2, '0');
    final minutes = diff.inMinutes.remainder(60).toString().padLeft(2, '0');
    return '预计可签到倒计时 $hours:$minutes';
  }

  void _loadLocalCaches() {
    final read = box.read<Map>(_localReadCacheKey);
    if (read != null) {
      for (final entry in read.entries) {
        final key = entry.key.toString();
        final value = entry.value == true;
        _localReadCache[key] = value;
      }
    }
    final views = box.read<Map>(_localViewCacheKey);
    if (views != null) {
      for (final entry in views.entries) {
        final key = entry.key.toString();
        final value = int.tryParse(entry.value.toString());
        if (value != null) _localViewCache[key] = value;
      }
    }
  }

  void _trimLocalCache<K, V>(Map<K, V> cache) {
    while (cache.length > _localCacheMax) {
      cache.remove(cache.keys.first);
    }
  }

  void _persistLocalReadCache() {
    _trimLocalCache(_localReadCache);
    box.write(_localReadCacheKey, Map<String, bool>.from(_localReadCache));
  }

  void _persistLocalViewCache() {
    _trimLocalCache(_localViewCache);
    box.write(_localViewCacheKey, Map<String, int>.from(_localViewCache));
  }

  void applyLocalOverrides(DiscussionModel discussion) {
    final id = discussion.id;
    final read = _localReadCache[id];
    if (read == true) discussion.isRead = true;
    final views = _localViewCache[id];
    if (views != null && views > discussion.views) {
      discussion.views = views;
    }
  }

  void markDiscussionReadAndViewed(DiscussionModel discussion) {
    final id = discussion.id;
    if (id.isEmpty) return;
    discussion.isRead = true;
    _localReadCache[id] = true;
    final nextViews = discussion.views + 1;
    discussion.views = nextViews;
    final cachedViews = _localViewCache[id];
    if (cachedViews == null || nextViews > cachedViews) {
      _localViewCache[id] = nextViews;
    }
    _persistLocalReadCache();
    _persistLocalViewCache();
    HDataModel.upsertCachedDiscussion(discussion);
    searchResult.refresh();
    bookmarks.refresh();
    history.refresh();
  }

  bool canVisit(DiscussionModel discussion, bool isPin) => true;

  final curPage = 0.obs;

  final accelerator = ''.obs;

  @override
  void onClose() {
    _newPostCheckTimer?.cancel();
    super.onClose();
  }

  @override
  Future<void> onInit() async {
    super.onInit();
    pref = await SharedPreferencesWithCache.create(
      cacheOptions: const SharedPreferencesWithCacheOptions(),
    );
    _loadLocalCaches();
    pageController
        .addListener(() => curPage(pageController.page?.round() ?? 0));
    pref.remove('root_token');
    isLogin(pref.getBool('isLogin') ?? false);
    ever(isLogin, (v) => pref.setBool('isLogin', v));
    ever(user, (u) {
      if (u?.userId != null) {
        box.write('userId', u!.userId);
      } else {
        box.remove('userId');
      }
    });
    logger.i(isLogin());
    accelerator(pref.getString('accelerator') ?? '');
    ever(accelerator, (v) => pref.setString('accelerator', v));

    // Always check for user info if token exists
    final token = getToken();
    if (token.isNotEmpty) {
      isLogin(true);
      try {
        await refreshSelfUserInfo();
        await refreshFavorites();
      } catch (e) {
        // Handle 401 explicitly if it bubbles up, though BaseConnect usually handles it globally.
        // But here we want to show a specific message "Account not found or abnormal".
        if (e is ApiException && e.statusCode == 401) {
          logger.e('Failed to get user info: Unauthorized', error: e);
          isLogin(false);
          showToast('账号不存在或异常', isError: true);
        } else {
          logger.e('Failed to get user info', error: e);
        }
      }
    } else {
      // Check for pending activation credentials
      final pendingEmail = box.read<String>('pending_activation_email');
      final pendingPassword = box.read<String>('pending_activation_password');
      if (pendingEmail != null && pendingPassword != null) {
        // Try to login silently
        try {
          final res =
              await BaseConnect.authApi.login(pendingEmail, pendingPassword);
          if (res.token != null) {
            await setToken(res.token!);
            user(res.user);
            await ensureAuthorForUser(res.user);
            isLogin(true);
            await refreshSelfUserInfo();
            await refreshFavorites();
            // Clear pending credentials
            box.remove('pending_activation_email');
            box.remove('pending_activation_password');
            showToast('登录成功：欢迎回来，绳匠！');
          }
        } catch (e) {
          // Ignore failures, user will see waiting screen in LoginPage if they go there
          logger.w('Auto-login from pending activation failed: $e');
        }
      }
    }

    ever(isLogin, (v) async {
      if (v) {
        // fetch user info if not present
        if (user.value == null) {
          try {
            await refreshSelfUserInfo();
            await refreshFavorites();
          } catch (e) {
            logger.e('Failed to fetch user after login', error: e);
          }
        } else {
          await refreshFavorites();
        }
      } else {
        final u = user.value;
        user.value = null;
        authorId.value = null;
        _clearCachedAvatarForUser(u);
        box.remove('access_token');
        bookmarks.clear();
        favoriteIds.clear();
        _localReadCache.clear();
        _localViewCache.clear();
        box.remove(_localReadCacheKey);
        box.remove(_localViewCacheKey);
      }
    });

    debounce(
      searchQuery,
      (query) async {
        searchController.text = query;
        searchResult.clear();
        searchEndCur = null;
        searchHasNextPage.value = true;
        searchCache.clear();
        isSearching(true);
        await searchData();
        isSearching(false);
      },
      time: 500.ms,
    );
    isSearching(true);
    // Load cached search result if available (offline support)
    final cachedSearch = box.read<List<dynamic>>(_searchCacheKey);
    if (cachedSearch != null && cachedSearch.isNotEmpty) {
      try {
        final list = cachedSearch
            .map((e) => HDataModel.fromJson(e as Map<String, dynamic>))
            .toSet();
        searchResult.addAll(list);
      } catch (e) {
        logger.e('Failed to load offline cache', error: e);
      }
    }

    try {
      await searchData();
    } catch (e) {
      logger.e('Initial search failed', error: e);
    } finally {
      isSearching(false);
    }
    history.addAll(pref
            .getStringList(_historyKey)
            ?.map((e) =>
                HDataModel.fromJson(jsonDecode(e) as Map<String, dynamic>))
            .cast<HDataModel>() ??
        []);
    debounce(
      history,
      (_) => _saveHistoryToLocal(),
      time: 800.ms,
    );

    // Reports and Version
    // api.getAllReports...
    // api.getNewVersion...

    _startNewPostCheck();
  }

  void _startNewPostCheck() {
    _newPostCheckTimer?.cancel();
    _newPostCheckTimer = Timer.periodic(const Duration(seconds: 15), (timer) {
      _checkNewPosts();
    });
  }

  Future<void> _checkNewPosts() async {
    if (searchQuery.isNotEmpty) return;
    // Don't check if we are currently searching/refreshing
    if (isSearching.value) return;

    try {
      final pagination = await api.search('', '');

      // Check again if we started searching while waiting for api
      if (isSearching.value) return;

      if (pagination.nodes.isEmpty) return;

      // Remote non-pinned posts
      final remoteList = pagination.nodes.where((e) => !e.isPinned).toList();

      // Local non-pinned posts
      final localList = searchResult.where((e) => !e.isPinned).toList();

      if (localList.isEmpty) {
        // Only trigger update if we expect local list to be populated but it is empty
        // However, if searchResult was cleared by refreshSearchData, we should skip
        if (isSearching.value) return;

        // If we really have no local data (e.g. initial load failed?), then maybe we should sync
        // But usually this means a refresh is pending or happened.
        // Let's be safe: if local is empty, don't report "20 new posts" unless we are sure.
        return;
      }

      final localNewestCreatedAt = localList
          .map((e) => e.createdAt)
          .reduce((a, b) => a.isAfter(b) ? a : b);

      final count = remoteList
          .where((e) => e.createdAt.isAfter(localNewestCreatedAt))
          .length;

      if (count > 0) {
        newPostCount.value = count;
      } else {
        newPostCount.value = 0;
      }
      hasContentChange.value = false;
    } catch (e) {
      // Silent error
    }
  }

  Future<void> showNewPosts() async {
    newPostCount.value = 0;
    hasContentChange.value = false;
    // Scroll to top is handled in UI usually, but refresh data here
    await refreshSearchData();
  }

  Future<void> refreshFavorites() async {
    final username = user.value?.login ?? '';
    if (isLogin.isFalse || username.isEmpty) {
      bookmarks.clear();
      favoriteIds.clear();
      return;
    }

    final result = await api.getFavorites(username, '');
    bookmarks(result.items.toSet());
    favoriteIds.assignAll(result.favoriteIds);
  }

  Future<void> toggleFavorite(HDataModel hData) async {
    if (isLogin.isFalse) {
      showToast('请先登录', isError: true);
      return;
    }
    final userId = user.value?.userId;
    final username = user.value?.login ?? '';
    if (userId == null || userId.isEmpty || username.isEmpty) {
      showToast('用户信息获取失败', isError: true);
      return;
    }

    final articleId = hData.id;
    if (articleId.isEmpty) return;

    var favoriteId = favoriteIds[articleId];
    if (favoriteId == null) {
      favoriteId = await api.getFavoriteId(
        username: username,
        articleId: articleId,
      );
      if (favoriteId != null && favoriteId.isNotEmpty) {
        favoriteIds[articleId] = favoriteId;
        bookmarks({hData, ...bookmarks});
      }
    }

    if (favoriteId != null && favoriteId.isNotEmpty) {
      final ok = await api.deleteFavorite(favoriteId);
      if (ok) {
        favoriteIds.remove(articleId);
        bookmarks.removeWhere((e) => e.id == articleId);
      } else {
        showToast('取消收藏失败', isError: true);
      }
    } else {
      final newId = await api.createFavorite(
        userId: userId,
        articleId: articleId,
      );
      if (newId != null && newId.isNotEmpty) {
        favoriteIds[articleId] = newId;
        bookmarks({hData, ...bookmarks});
      } else {
        showToast('收藏失败', isError: true);
      }
    }
  }

  final selectedIndex = 0.obs;
  final pageController = PageController();

  Future<void> animateToPage(int index, {bool animate = false}) {
    selectedIndex.value = index;
    if (animate) {
      return pageController.animateToPage(
        index,
        duration: 0.5.s,
        curve: Curves.ease,
      );
    } else {
      if (pageController.hasClients) {
        pageController.jumpToPage(index);
      } else {
        // Desktop/Compact mode where PageView is not used
        curPage.value = index;
      }
      return Future.value();
    }
  }

  bool isFetchPinDiscussions = true;
  final searchController = SearchController();

  late final refreshSearchData = throttle(() async {
    // 重置定时器，避免刷新时刚好触发轮询
    _startNewPostCheck();
    isSearching(true);
    try {
      logger.i('Refreshing search data...');
      searchHasNextPage.value = true;
      searchEndCur = null;
      searchCache.clear();
      HDataModel.discussionsCache.clear(); // 清空详情缓存
      searchResult.clear();
      newPostCount.value = 0;
      hasContentChange.value = false;
      await searchData();
      logger.i('Refreshed. Result count: ${searchResult.length}');
    } finally {
      isSearching(false);
    }
  }, Duration.zero);

  final searchCache = <String?>{};
  Future<void> searchData() async {
    if (searchHasNextPage.isFalse || searchCache.contains(searchEndCur)) return;
    searchCache.add(searchEndCur);

    final isFirstPage = searchEndCur == null || searchEndCur!.isEmpty;

    final pagination = await api.search(searchQuery(), searchEndCur ?? '');
    // pagination returns PaginationModel<HDataModel>
    // destructure:
    searchEndCur = pagination.endCursor;
    searchHasNextPage.value = pagination.hasNextPage;

    if (isFirstPage) {
      searchResult.assignAll(pagination.nodes);
    } else {
      searchResult.addAll(pagination.nodes);
    }

    // Save to offline cache if this is the first page of default search
    if ((searchEndCur == null ||
            searchEndCur!.isEmpty ||
            searchEndCur == ApiConfig.defaultPageSize.toString()) &&
        searchQuery().isEmpty) {
      try {
        final cacheList = searchResult.map((e) => e.toJson()).toList();
        box.write(_searchCacheKey, cacheList);
      } catch (e) {
        logger.e('Failed to save offline cache', error: e);
      }
    }

    await updateUserAvatarFromDiscussionsCache();
  }

  Future<String?> ensureAuthorForUser(AuthorModel? u) async {
    if (u == null) return null;
    if (u.authorId != null && u.authorId!.isNotEmpty) {
      authorId.value = u.authorId;
      return u.authorId;
    }
    final name = (u.name.isNotEmpty ? u.name : u.login).trim();
    if (name.isEmpty) return null;
    final id = await api.ensureAuthorId(
      name: name,
      userId: u.userId,
    );
    if (id != null && id.isNotEmpty) {
      authorId.value = id;
      if (u.userId != null && u.userId!.isNotEmpty) {
        try {
          await api.linkAuthorToUser(authorId: id, userId: u.userId!);
        } catch (_) {
          // Best-effort linking; avoid blocking login flow.
        }
      }
    }
    return id;
  }

  Future<bool> ensureLogin() async {
    if (isLogin.value) return true;
    final context = Get.context;
    if (context != null) {
      await showZZZDialog(
        context: context,
        pageBuilder: (context) => const LoginPage(),
      );
    }
    return isLogin.value;
  }

  Future<void> pickAndUploadAvatar() async {
    if (isLogin.isFalse) {
      if (!await ensureLogin()) return;
    }
    if (isUploadingAvatar.value) return;

    final picker = ImagePicker();
    final file = await picker.pickImage(
      source: ImageSource.gallery,
      imageQuality: 90,
      maxWidth: 1024,
      maxHeight: 1024,
    );
    if (file == null) return;

    final allowedExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp'];
    final ext = file.name.split('.').last.toLowerCase();
    if (!allowedExtensions.contains(ext)) {
      showToast('不支持的文件格式，仅支持 JPEG, PNG, GIF, WEBP', isError: true);
      return;
    }

    isUploadingAvatar(true);
    try {
      final curUser = user.value;
      final targetAuthorId = authorId.value ??
          curUser?.authorId ??
          await ensureAuthorForUser(curUser);
      if (targetAuthorId == null || targetAuthorId.isEmpty) {
        throw Exception('未找到作者信息');
      }

      final bytes = await file.readAsBytes();
      final avatarUrl = await api.uploadAvatar(
        authorId: targetAuthorId,
        bytes: bytes,
        filename: file.name,
      );
      final current = user.value;
      if (current != null && avatarUrl != null && avatarUrl.isNotEmpty) {
        final refreshed = _withCacheBuster(avatarUrl);
        current.avatar = refreshed;
        _cacheAvatarForUser(current, refreshed);
        user.refresh();
        await _refreshAvatarCaches(refreshed);
      }
      await refreshSelfUserInfo();
      showToast('头像已更新'.tr);
    } catch (e) {
      showToast('头像上传失败: $e', isError: true);
    } finally {
      isUploadingAvatar(false);
    }
  }

  Future<void> updateUsername(String newName) async {
    if (isLogin.isFalse) {
      showToast('请先登录', isError: true);
      return;
    }

    final curUser = user.value;
    if (curUser == null || curUser.userId == null) {
      showToast('用户信息异常', isError: true);
      return;
    }

    if (curUser.login == newName) return;

    try {
      // 1. Update User (username)
      final updatedUser = await api.updateUser(
        curUser.userId!,
        {'username': newName},
      );

      // 2. Update Author (name) if exists
      final authorIdVal = authorId.value ?? curUser.authorId;
      if (authorIdVal != null && authorIdVal.isNotEmpty) {
        try {
          await api.updateAuthor(
            authorId: authorIdVal,
            data: {'name': newName},
          );
        } catch (e) {
          logger.w('Failed to update Author name', error: e);
        }
      }

      // 3. Update local state
      updatedUser.avatar = curUser.avatar;
      user(updatedUser);
      await ensureAuthorForUser(updatedUser);

      showToast('用户名已更新');
    } catch (e) {
      logger.e('Update username failed', error: e);
      showToast('用户名更新失败: $e', isError: true);
    }
  }
}
